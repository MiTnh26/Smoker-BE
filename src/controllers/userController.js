


const { accountModel,entityAccountModel } = require("../models");
const { success, error } = require("../utils/response");

async function me(req, res) {
  try {
    const userId = req.user.id;
    const user = await accountModel.getAccountById(userId);
    if (!user) return res.status(404).json(error("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng"));

    // Parse address n·∫øu l√† JSON, n·∫øu kh√¥ng th√¨ tr·∫£ v·ªÅ nh∆∞ string
    let address = user.Address || "";
    let addressData = null;
    
    if (address) {
      try {
        const parsed = JSON.parse(address);
        if (parsed && typeof parsed === 'object' && parsed.fullAddress !== undefined) {
          // ƒê√¢y l√† structured address data
          addressData = {
            provinceId: parsed.provinceId || null,
            districtId: parsed.districtId || null,
            wardId: parsed.wardId || null,
            fullAddress: parsed.fullAddress || ""
          };
          address = parsed.fullAddress || parsed.detail || address;
        }
      } catch (e) {
        // Kh√¥ng ph·∫£i JSON, d√πng nh∆∞ string b√¨nh th∆∞·ªùng
        address = user.Address || "";
      }
    }

    return res.json(success("L·∫•y th√¥ng tin th√†nh c√¥ng", {
      id: user.AccountId,
      email: user.Email,
      userName: user.UserName,
      role: user.Role,
      avatar: user.Avatar,
      background: user.Background,
      coverImage: user.Background,
      phone: user.Phone,
      address: address,
      addressData: addressData, // Th√™m structured address data
      bio: user.Bio,
      gender: user.Gender,
      status: user.Status,
      createdAt: user.created_at
    }));
  } catch (e) {
    console.error("me() error:", e);
    return res.status(500).json(error("L·ªói m√°y ch·ªß"));
  }
}

async function updateProfile(req, res) {
  console.log("=== updateProfile ===");
  console.log("[USER] req.user:", req.user);
  console.log("[USER] req.body:", req.body);
  console.log("[USER] req.files:", req.files);
  console.log("[USER] req.body.avatar:", req.body?.avatar);
  console.log("[USER] req.body.background:", req.body?.background);

  try {
    const userId = req.user.id;
    let { userName, bio, address, phone, gender, status, addressData } = req.body || {};

    // üîí Validate c∆° b·∫£n
    userName = (userName || "").trim();
    if (userName && userName.length < 4)
      return res.status(400).json(error("T√™n ng∆∞·ªùi d√πng ph·∫£i c√≥ √≠t nh·∫•t 4 k√Ω t·ª±"));

    bio = (bio || "").slice(0, 500);
    
    // X·ª≠ l√Ω address: n·∫øu c√≥ addressData (structured), l∆∞u d∆∞·ªõi d·∫°ng JSON
    // N·∫øu kh√¥ng, l∆∞u nh∆∞ string b√¨nh th∆∞·ªùng
    let addressToSave = (address || "").trim();
    if (addressData) {
      try {
        // Parse addressData n·∫øu l√† string JSON
        const addressDataObj = typeof addressData === 'string' 
          ? JSON.parse(addressData) 
          : addressData;
        
        // L∆∞u d∆∞·ªõi d·∫°ng JSON string ch·ª©a c·∫£ full address v√† structured data
        addressToSave = JSON.stringify({
          fullAddress: address || addressDataObj.fullAddress || "",
          provinceId: addressDataObj.provinceId || null,
          districtId: addressDataObj.districtId || null,
          wardId: addressDataObj.wardId || null,
          detail: addressDataObj.detail || address || ""
        });
      } catch (e) {
        console.warn("[USER] Failed to parse addressData, saving as plain string:", e);
        // N·∫øu parse l·ªói, l∆∞u nh∆∞ string b√¨nh th∆∞·ªùng
        addressToSave = (address || "").trim();
      }
    }
    
    phone = (phone || "").replace(/\s/g, "").slice(0, 20);
    if (phone && !/^0\d{9,10}$/.test(phone))
      return res.status(400).json(error("S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá"));

    gender = gender?.toLowerCase() || null;
    if (gender && !["male", "female"].includes(gender))
      return res.status(400).json(error("Gi·ªõi t√≠nh kh√¥ng h·ª£p l·ªá"));



    const current = await accountModel.getAccountById(userId);
    if (!current) return res.status(404).json(error("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng"));
    
    // Check if avatar/background are in files (uploaded) or body (URL)
    const fileAvatar = req.files?.avatar?.[0]?.path;
    const fileBackground = req.files?.background?.[0]?.path;
    
    // If no files uploaded, check if URLs are in body
    const avatarUrl = req.body?.avatar || fileAvatar;
    const backgroundUrl = req.body?.background || fileBackground;
    
    console.log("[USER] fileAvatar:", fileAvatar);
    console.log("[USER] fileBackground:", fileBackground);
    console.log("[USER] avatarUrl:", avatarUrl);
    console.log("[USER] backgroundUrl:", backgroundUrl);
    console.log("[USER] current.Avatar:", current.Avatar);
    console.log("[USER] current.Background:", current.Background);

    const updateData = {
      userName: userName || current.UserName,
      bio,
      address: addressToSave,
      phone,
      gender: gender || current.Gender,
      status: status || current.Status,
      avatar: avatarUrl || current.Avatar,
      background: backgroundUrl || current.Background,
    };
    
    console.log("[USER] updateData:", updateData);

    const updated = await accountModel.updateAccountInfo(userId, updateData);
    if (!updated) return res.status(400).json(error("C·∫≠p nh·∫≠t th·∫•t b·∫°i"));

    // Parse address ƒë·ªÉ tr·∫£ v·ªÅ structured data n·∫øu c√≥
    let parsedAddress = updated.Address || "";
    let parsedAddressData = null;
    
    if (parsedAddress) {
      try {
        const parsed = JSON.parse(parsedAddress);
        if (parsed && typeof parsed === 'object' && parsed.fullAddress !== undefined) {
          parsedAddressData = {
            provinceId: parsed.provinceId || null,
            districtId: parsed.districtId || null,
            wardId: parsed.wardId || null,
            fullAddress: parsed.fullAddress || ""
          };
          parsedAddress = parsed.fullAddress || parsed.detail || parsedAddress;
        }
      } catch (e) {
        // Kh√¥ng ph·∫£i JSON, d√πng nh∆∞ string
        parsedAddress = updated.Address || "";
      }
    }

    return res.json(success("C·∫≠p nh·∫≠t h·ªì s∆° th√†nh c√¥ng", {
      id: updated.AccountId,
      email: updated.Email,
      userName: updated.UserName,
      role: updated.Role,
      avatar: updated.Avatar,
      background: updated.Background,
      phone: updated.Phone,
      address: parsedAddress,
      addressData: parsedAddressData, // Th√™m structured address data
      bio: updated.Bio,
      gender: updated.Gender,
      status: updated.Status,
      createdAt: updated.created_at
    }));
  } catch (e) {
    console.error("updateProfile error:", e);
    return res.status(500).json(error(e?.message || "L·ªói m√°y ch·ªß"));
  }
}
async function getEntities(req, res) {
  try {
    const accountId = req.params.accountId;
    if (!accountId) return res.status(400).json(error("Thi·∫øu accountId"));

    const entities = await entityAccountModel.getEntitiesByAccountId(accountId);

    return res.json(entities); // tr·∫£ v·ªÅ m·∫£ng entity ƒë√£ normalize t·ª´ model
  } catch (err) {
    console.error("getEntities error:", err);
    return res.status(500).json(error("L·ªói server khi l·∫•y entities"));
  }
}
module.exports = { me, updateProfile,getEntities };

